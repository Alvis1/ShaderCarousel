<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>TSL Universal Component Demo - A-Frame WebGPU</title>
    <meta name="description" content="Universal TSL Shader Component Demo">
    
    <!-- Import maps for local Three.js WebGPU -->
    <script type="importmap">
    {
        "imports": {
            "aframe": "./components/three/aframe-master.module.min.js",
            "three": "./components/three/super-three.webgpu.js",
            "three/webgpu": "./components/three/super-three.webgpu.js",
            "three/tsl": "./components/three/super-three.tsl.js"
        }
    }
    </script>
    
    <script type="module">
        import AFRAME from 'aframe';
        import * as THREE from 'three';
        
        // Set up global THREE for A-Frame compatibility
        const THREE_GLOBAL = {};
        const copyKeys = [...Object.getOwnPropertyNames(THREE), ...Object.getOwnPropertySymbols(THREE)];
        for (const key of copyKeys) {
            const descriptor = Object.getOwnPropertyDescriptor(THREE, key) ?? { enumerable: true };
            Object.defineProperty(THREE_GLOBAL, key, {
                value: THREE[key],
                enumerable: descriptor.enumerable,
                configurable: true,
                writable: true
            });
        }
        window.THREE = THREE_GLOBAL;
    </script>
    
    <!-- Register TSL Component after A-Frame is loaded -->
    <script>
        // Wait for A-Frame to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            AFRAME.registerComponent('tsl-shader', {
                schema: {
                    // Shader source - can be shader name or full/relative path to .js file
                    src: {type: 'string', default: 'polka-dots'},
                    
                    // Common TSL shader parameters
                    count: {type: 'number', default: 2},
                    size: {type: 'number', default: 0.5},
                    blur: {type: 'number', default: 0.25},
                    color: {type: 'color', default: '#000000'},
                    background: {type: 'color', default: '#ffffff'},
                    
                    // Material properties
                    roughness: {type: 'number', default: 0.5},
                    metalness: {type: 'number', default: 0.0},
                    
                    // Additional shader-specific parameters
                    flat: {type: 'number', default: 0},
                    seed: {type: 'number', default: 0},
                    
                    // Debug mode
                    debug: {type: 'boolean', default: false}
                },
                
                init() {
                    this.setupMaterial();
                },
                
                async setupMaterial() {
                    const data = this.data;
                    
                    try {
                        let shaderPath, shaderFunctionName, shaderFunction;
                        
                        // Determine shader path and function name
                        if (data.src.includes('/') || data.src.endsWith('.js')) {
                            // Full or relative path provided
                            shaderPath = data.src;
                            // Extract function name from filename (convert kebab-case to camelCase)
                            const filename = data.src.split('/').pop().replace('.js', '');
                            shaderFunctionName = this.kebabToCamel(filename);
                        } else {
                            // Just shader name provided - load from tsl directory
                            shaderPath = `./tsl/${data.src}.js`;
                            shaderFunctionName = this.kebabToCamel(data.src);
                        }
                        
                        if (data.debug) {
                            console.log(`[TSL Shader] Loading: ${shaderPath} -> ${shaderFunctionName}`);
                        }
                        
                        // Import the shader module
                        const shaderModule = await import(shaderPath);
                        shaderFunction = shaderModule[shaderFunctionName];
                        
                        if (!shaderFunction) {
                            console.error(`[TSL Shader] Function '${shaderFunctionName}' not found in ${shaderPath}`);
                            console.log('[TSL Shader] Available exports:', Object.keys(shaderModule));
                            
                            // Try common alternative names
                            const alternatives = [
                                data.src,
                                data.src.toLowerCase(),
                                this.kebabToCamel(data.src.replace(/-/g, '_')),
                                'default'
                            ];
                            
                            for (const alt of alternatives) {
                                if (shaderModule[alt]) {
                                    shaderFunction = shaderModule[alt];
                                    console.log(`[TSL Shader] Found function using alternative name: ${alt}`);
                                    break;
                                }
                            }
                            
                            if (!shaderFunction) {
                                console.error('[TSL Shader] Could not resolve shader function');
                                return;
                            }
                        }
                        
                        // Create TSL material
                        const material = new THREE.MeshStandardNodeMaterial({
                            roughness: data.roughness,
                            metalness: data.metalness
                        });
                        
                        // Prepare shader parameters (only include defined/non-default values)
                        const shaderParams = {};
                        const paramKeys = ['count', 'size', 'blur', 'color', 'background', 'flat', 'seed'];
                        
                        paramKeys.forEach(key => {
                            const value = data[key];
                            if (value !== undefined) {
                                if (key === 'color' || key === 'background') {
                                    shaderParams[key] = new THREE.Color(value);
                                } else {
                                    shaderParams[key] = value;
                                }
                            }
                        });
                        
                        if (data.debug) {
                            console.log('[TSL Shader] Parameters:', shaderParams);
                        }
                        
                        // Apply TSL shader with parameters
                        material.colorNode = shaderFunction(shaderParams);
                        
                        // Apply to mesh
                        this.applyMaterial(material);
                        
                        if (data.debug) {
                            console.log('[TSL Shader] Material applied successfully');
                        }
                        
                    } catch (error) {
                        console.error('[TSL Shader] Error setting up material:', error);
                        console.error('[TSL Shader] Stack trace:', error.stack);
                        
                        // Fallback to basic material
                        this.applyFallbackMaterial();
                    }
                },
                
                applyMaterial(material) {
                    const mesh = this.el.getObject3D('mesh');
                    if (mesh) {
                        mesh.material = material;
                        mesh.material.needsUpdate = true;
                    } else {
                        // Wait for mesh to be created
                        this.el.addEventListener('object3dset', () => {
                            const newMesh = this.el.getObject3D('mesh');
                            if (newMesh) {
                                newMesh.material = material;
                                newMesh.material.needsUpdate = true;
                            }
                        });
                    }
                },
                
                applyFallbackMaterial() {
                    const fallbackMaterial = new THREE.MeshStandardMaterial({
                        color: this.data.color,
                        roughness: this.data.roughness,
                        metalness: this.data.metalness
                    });
                    
                    this.applyMaterial(fallbackMaterial);
                    console.warn('[TSL Shader] Applied fallback material');
                },
                
                kebabToCamel(str) {
                    return str.replace(/-([a-z])/g, function (g) { 
                        return g[1].toUpperCase(); 
                    });
                },
                
                update() {
                    // Re-setup material when component data changes
                    this.setupMaterial();
                },
                
                remove() {
                    // Clean up material when component is removed
                    const mesh = this.el.getObject3D('mesh');
                    if (mesh && mesh.material) {
                        if (mesh.material.dispose) {
                            mesh.material.dispose();
                        }
                    }
                }
            });
        });
    </script>
    
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }
        
        #info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 1000;
            font-size: 14px;
        }
        
        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
        }
        
        button {
            margin: 3px;
            padding: 6px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .shader-group {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>🎨 Universal TSL Component Demo</h3>
        <p><strong>Usage Examples:</strong></p>
        <code>tsl-shader="src: marble"</code><br>
        <code>tsl-shader="src: ./tsl/polka-dots.js"</code><br>
        <code>tsl-shader="src: zebra-lines; debug: true"</code>
        <p><small>WASD + Mouse to navigate<br>Click buttons to change shaders</small></p>
    </div>
    
    <div id="controls">
        <div class="shader-group">
            <strong>Main Object:</strong><br>
            <button onclick="changeMainShader('polka-dots')">Polka Dots</button>
            <button onclick="changeMainShader('marble')">Marble</button>
            <button onclick="changeMainShader('zebra-lines')">Zebra</button>
            <button onclick="changeMainShader('circles')">Circles</button>
        </div>
        <div class="shader-group">
            <button onclick="changeMainShader('tiger-fur')">Tiger Fur</button>
            <button onclick="changeMainShader('dalmatian-spots')">Dalmatian</button>
            <button onclick="changeMainShader('wood')">Wood</button>
            <button onclick="changeMainShader('rust')">Rust</button>
        </div>
        <div class="shader-group">
            <button onclick="randomizeAll()">🎲 Randomize All</button>
            <button onclick="toggleDebug()">🐛 Toggle Debug</button>
        </div>
    </div>

    <a-scene 
        stats 
        background="color: #1e3c72">
        
        <!-- Main showcase object (center) -->
        <a-icosahedron
            id="main-object"
            position="0 3 -6"
            radius="2"
            detail="1"
            animation="property: rotation; to: 0 360 0; loop: true; dur: 30000"
            tsl-shader="src: polka-dots; count: 4; size: 0.6; blur: 0.2; color: #ff0000; background: #ffffff; debug: false">
        </a-icosahedron>
        
        <!-- Row 1: Basic shader names -->
        <a-sphere
            position="-4 2 -4"
            radius="1"
            animation="property: rotation; to: 360 0 0; loop: true; dur: 20000"
            tsl-shader="src: marble; count: 1; size: 0.4; color: #444444; background: #F0F8FF">
        </a-sphere>
        
        <a-box
            position="4 2 -4"
            size="2 2 2"
            rotation="0 45 0"
            animation="property: rotation; to: 0 405 0; loop: true; dur: 25000"
            tsl-shader="src: zebra-lines; count: 8; size: 0.3; color: #000000; background: #ffff00">
        </a-box>
        
        <!-- Row 2: Full path examples -->
        <a-cylinder
            position="-6 1 -2"
            radius="0.8"
            height="1.5"
            animation="property: position; to: -6 1.5 -2; dir: alternate; loop: true; dur: 3000"
            tsl-shader="src: ./tsl/circles.js; count: 5; size: 0.5; blur: 0.2; color: #ff4444; background: #ffffff">
        </a-cylinder>
        
        <a-cylinder
            position="6 1 -2"
            radius="0.8"
            height="1.5"
            animation="property: position; to: 6 1.5 -2; dir: alternate; loop: true; dur: 4000"
            tsl-shader="src: ./tsl/tiger-fur.js; count: 3; size: 0.7; blur: 0.25; color: #ff8800; background: #000000">
        </a-cylinder>
        
        <!-- Row 3: More examples -->
        <a-torus
            position="-2 1 -1"
            radius="1"
            radius-tubular="0.3"
            animation="property: rotation; to: 0 0 360; loop: true; dur: 15000"
            tsl-shader="src: dalmatian-spots; count: 6; size: 0.8; blur: 0.3; color: #000000; background: #ffffff">
        </a-torus>
        
        <a-torus
            position="2 1 -1"
            radius="1"
            radius-tubular="0.3"
            animation="property: rotation; to: 0 0 -360; loop: true; dur: 18000"
            tsl-shader="src: wood; count: 2; size: 0.6; blur: 0.4; color: #8B4513; background: #F5DEB3">
        </a-torus>
        
        <!-- Ground with marble texture -->
        <a-plane 
            position="0 0 0" 
            rotation="-90 0 0" 
            width="30" 
            height="30"
            tsl-shader="src: marble; count: 3; size: 0.2; blur: 0.5; color: #333333; background: #888888; seed: 1">
        </a-plane>
        
        <!-- Lighting -->
        <a-light type="ambient" color="#404040" intensity="0.3"></a-light>
        <a-light 
            type="directional" 
            color="#ffffff" 
            intensity="1.0" 
            position="8 8 4"
            shadow="cast: true">
        </a-light>
        <a-light 
            type="point" 
            color="#ff6666" 
            intensity="0.5" 
            position="-5 3 -2">
        </a-light>
        
        <!-- Camera -->
        <a-entity 
            position="0 4 10"
            camera="fov: 60; near: 0.1; far: 100"
            look-controls
            wasd-controls="acceleration: 25; fly: true">
        </a-entity>
    </a-scene>
    
    <script>
        let debugMode = false;
        
        const SHADERS = [
            'polka-dots', 'marble', 'zebra-lines', 'circles', 'tiger-fur', 
            'dalmatian-spots', 'wood', 'rust', 'concrete', 'clouds', 
            'water-drops', 'voronoi-cells', 'stars', 'grid', 'neon-lights'
        ];
        
        const COLORS = [
            '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',
            '#ff8800', '#8800ff', '#00ff88', '#444444', '#ffffff', '#000000'
        ];
        
        function changeMainShader(shaderName) {
            const mainObject = document.getElementById('main-object');
            const randomColor = COLORS[Math.floor(Math.random() * COLORS.length)];
            const randomBg = COLORS[Math.floor(Math.random() * COLORS.length)];
            
            mainObject.setAttribute('tsl-shader', {
                src: shaderName,
                count: Math.random() * 6 + 2,
                size: Math.random() * 0.6 + 0.3,
                blur: Math.random() * 0.3 + 0.1,
                color: randomColor,
                background: randomBg,
                debug: debugMode
            });
            
            console.log(`Changed main shader to: ${shaderName}`);
        }
        
        function randomizeAll() {
            const entities = document.querySelectorAll('[tsl-shader]');
            
            entities.forEach(entity => {
                const randomShader = SHADERS[Math.floor(Math.random() * SHADERS.length)];
                const randomColor = COLORS[Math.floor(Math.random() * COLORS.length)];
                const randomBg = COLORS[Math.floor(Math.random() * COLORS.length)];
                
                entity.setAttribute('tsl-shader', {
                    src: randomShader,
                    count: Math.random() * 8 + 1,
                    size: Math.random() * 0.8 + 0.2,
                    blur: Math.random() * 0.4 + 0.05,
                    color: randomColor,
                    background: randomBg,
                    seed: Math.floor(Math.random() * 1000),
                    debug: debugMode
                });
            });
            
            console.log('Randomized all shaders!');
        }
        
        function toggleDebug() {
            debugMode = !debugMode;
            
            const entities = document.querySelectorAll('[tsl-shader]');
            entities.forEach(entity => {
                const currentData = entity.getAttribute('tsl-shader');
                entity.setAttribute('tsl-shader', 'debug', debugMode);
            });
            
            console.log(`Debug mode: ${debugMode ? 'ON' : 'OFF'}`);
        }
        
        // Auto-cycle main shader every 10 seconds
        setInterval(() => {
            const randomShader = SHADERS[Math.floor(Math.random() * SHADERS.length)];
            changeMainShader(randomShader);
        }, 10000);
        
    </script>
</body>
</html>