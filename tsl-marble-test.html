<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>TSL Marble Test - A-Frame WebGPU</title>
    <meta name="description" content="Testing TSL Marble Shader with A-Frame WebGPU">
    
    <!-- Import maps for local Three.js WebGPU -->
    <script type="importmap">
    {
        "imports": {
            "aframe": "./components/three/aframe-master.module.min.js",
            "three": "./components/three/super-three.webgpu.js",
            "three/webgpu": "./components/three/super-three.webgpu.js",
            "three/tsl": "./components/three/super-three.tsl.js"
        }
    }
    </script>
    
    <script type="module">
        import AFRAME from 'aframe';
        import * as THREE from 'three';
        
        // Set up global THREE for A-Frame compatibility
        const THREE_GLOBAL = {};
        const copyKeys = [...Object.getOwnPropertyNames(THREE), ...Object.getOwnPropertySymbols(THREE)];
        for (const key of copyKeys) {
            const descriptor = Object.getOwnPropertyDescriptor(THREE, key) ?? { enumerable: true };
            Object.defineProperty(THREE_GLOBAL, key, {
                value: THREE[key],
                enumerable: descriptor.enumerable,
                configurable: true,
                writable: true
            });
        }
        window.THREE = THREE_GLOBAL;
        
        // Register universal TSL shader component
        AFRAME.registerComponent('tsl-shader', {
            schema: {
                src: {type: 'string', default: 'marble'},
                count: {type: 'number', default: 2},
                size: {type: 'number', default: 0.5},
                blur: {type: 'number', default: 0.25},
                color: {type: 'color', default: '#000000'},
                background: {type: 'color', default: '#ffffff'},
                roughness: {type: 'number', default: 0.5},
                metalness: {type: 'number', default: 0.0},
                flat: {type: 'number', default: 0},
                seed: {type: 'number', default: 0}
            },
            
            init() {
                this.setupMaterial();
            },
            
            async setupMaterial() {
                const data = this.data;
                
                try {
                    let shaderPath, shaderFunctionName, shaderFunction;
                    
                    // Determine shader path and function name
                    if (data.src.endsWith('.js')) {
                        // Full path provided
                        shaderPath = data.src;
                        // Extract function name from filename (convert kebab-case to camelCase)
                        const filename = data.src.split('/').pop().replace('.js', '');
                        shaderFunctionName = this.kebabToCamel(filename);
                    } else {
                        // Just shader name provided
                        shaderPath = `./tsl/${data.src}.js`;
                        shaderFunctionName = this.kebabToCamel(data.src);
                    }
                    
                    console.log(`Loading TSL shader: ${shaderPath} -> ${shaderFunctionName}`);
                    
                    // Import the shader module
                    const shaderModule = await import(shaderPath);
                    shaderFunction = shaderModule[shaderFunctionName];
                    
                    if (!shaderFunction) {
                        console.error(`Shader function '${shaderFunctionName}' not found in ${shaderPath}`);
                        console.log('Available exports:', Object.keys(shaderModule));
                        return;
                    }
                    
                    // Create TSL material
                    const material = new THREE.MeshStandardNodeMaterial({
                        roughness: data.roughness,
                        metalness: data.metalness
                    });
                    
                    // Prepare shader parameters (only include defined values)
                    const shaderParams = {};
                    const paramKeys = ['count', 'size', 'blur', 'color', 'background', 'flat', 'seed'];
                    
                    paramKeys.forEach(key => {
                        if (data[key] !== undefined) {
                            if (key === 'color' || key === 'background') {
                                shaderParams[key] = new THREE.Color(data[key]);
                            } else {
                                shaderParams[key] = data[key];
                            }
                        }
                    });
                    
                    console.log('Shader parameters:', shaderParams);
                    
                    // Apply TSL shader with parameters
                    material.colorNode = shaderFunction(shaderParams);
                    
                    // Apply to mesh
                    this.applyMaterial(material);
                    
                } catch (error) {
                    console.error('Error setting up TSL material:', error);
                    console.error('Stack trace:', error.stack);
                }
            },
            
            kebabToCamel(str) {
                return str.replace(/-([a-z])/g, function (g) { 
                    return g[1].toUpperCase(); 
                });
            },
            
            applyMaterial(material) {
                const mesh = this.el.getObject3D('mesh');
                if (mesh) {
                    mesh.material = material;
                    mesh.material.needsUpdate = true;
                } else {
                    this.el.addEventListener('object3dset', () => {
                        const newMesh = this.el.getObject3D('mesh');
                        if (newMesh) {
                            newMesh.material = material;
                            newMesh.material.needsUpdate = true;
                        }
                    });
                }
            },
            
            update() {
                this.setupMaterial();
            }
        });
        

    </script>
    
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }
        
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸŽ¨ TSL Shader Test</h3>
        <p>Testing Marble & Polka Dots</p>
        <p>WASD + Mouse to navigate</p>
    </div>

    <a-scene 
        stats 
        background="color: #201919">
        
        <!-- Marble sphere -->
        <a-sphere
            position="-2 2 -5"
            radius="1.5"
            animation="property: rotation; to: 0 360 0; loop: true; dur: 30000"
            tsl-shader="src: marble; count: 1; size: 0.4; blur: 0.3; color: #444444; background: #F0F8FF; seed: 0">
        </a-sphere>
        
        <!-- Polka dots sphere -->
        <a-sphere
            position="2 2 -5"
            radius="1.5"
            animation="property: rotation; to: 0 -360 0; loop: true; dur: 25000"
            tsl-shader="src: polka-dots; count: 4; size: 0.6; blur: 0.2; color: #ff0000; background: #ffffff; flat: 0">
        </a-sphere>
        
        <!-- Marble ground -->
        <a-plane 
            position="0 0 0" 
            rotation="-90 0 0" 
            width="20" 
            height="20"
            tsl-shader="src: marble; count: 2; size: 0.2; blur: 0.4; color: #333333; background: #cccccc; seed: 1">
        </a-plane>
        
        <!-- Test boxes with different shaders -->
        <a-box 
            position="-4 1 -3" 
            rotation="0 45 0"
            tsl-shader="src: polka-dots; count: 6; size: 0.3; blur: 0.1; color: #000000; background: #ffff00; flat: 1">
        </a-box>
        
        <a-box 
            position="4 1 -3" 
            rotation="0 -45 0"
            tsl-shader="src: ./tsl/zebra-lines.js; count: 8; size: 0.4; blur: 0.15; color: #000000; background: #ffffff">
        </a-box>
        
        <!-- Additional test objects with different TSL shaders -->
        <a-cylinder 
            position="-6 1 -2" 
            radius="0.8" 
            height="1.5"
            tsl-shader="src: circles; count: 5; size: 0.5; blur: 0.2; color: #ff4444; background: #ffffff">
        </a-cylinder>
        
        <a-cylinder 
            position="6 1 -2" 
            radius="0.8" 
            height="1.5"
            tsl-shader="src: tiger-fur; count: 3; size: 0.7; blur: 0.25; color: #ff8800; background: #000000">
        </a-cylinder>
        
        <!-- Lighting -->
        <a-light type="ambient" color="#404040" intensity="0.4"></a-light>
        <a-light 
            type="directional" 
            color="#ffffff" 
            intensity="0.8" 
            position="5 5 2">
        </a-light>
        
        <!-- Camera -->
        <a-entity 
            position="0 2 8"
            camera="fov: 50; near: 0.1; far: 100"
            look-controls
            wasd-controls="acceleration: 20">
        </a-entity>
    </a-scene>
</body>
</html>